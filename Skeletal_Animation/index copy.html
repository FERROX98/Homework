<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WebGL GLTF Skinning</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="data:,">
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: #000;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>
  <canvas id="glcanvas"></canvas>
  <div id="ui" style="position:fixed;top:10px;left:10px;z-index:10">
    <button id="btn-forward">Go Forward</button>
    <button id="btn-turn">Turn Right</button>
    <button id="btn-spin">Spin</button>
    <button id="btn-reset">Reset</button>
  </div>
  <div id="fps" style="position:fixed;top:10px;right:10px;color:#fff;z-index:10;font-family:monospace"></div>
  <script type="module">
    import { mat4, quat } from 'https://cdn.jsdelivr.net/npm/gl-matrix@3.4.3/esm/index.js';

    const canvas = document.getElementById("glcanvas");
   // Initialize the WebGL canvas
	canvas.oncontextmenu = function() {return false;};
	 const gl = canvas.getContext("webgl2", {antialias: false, depth: true});	// Initialize the GL context
	if (!gl) {
		alert("Unable to initialize WebGL. Your browser or machine may not support it.");
		
	}
	
	// Initialize settings
	gl.clearColor(0,0,0,0);
	gl.enable(gl.DEPTH_TEST);
    // === ENVIRONMENT SHADERS ===
    let envProgram, envVAOs = [], envCounts = [], envColors = [];
    function createEnvShader() {
      const vs = `#version 300 es
      precision highp float;
      in vec3 position;
      in vec3 normal;
      uniform mat4 projection, view, model;
      out vec3 vNormal;
      void main() {
        gl_Position = projection * view * model * vec4(position, 1.0);
        vNormal = mat3(transpose(inverse(model))) * normal;
      }`;
      const fs = `#version 300 es
      precision highp float;
      in vec3 vNormal;
      uniform vec3 color;
      out vec4 fragColor;
      void main() {
        vec3 lightDir = normalize(vec3(0.5, 1.0, 0.8));
        float diff = max(dot(normalize(vNormal), lightDir), 0.0);
        fragColor = vec4(color  , 1.0);
      }`;
      envProgram = createProgram(gl, vs, fs);
    }

    let program, vao, indexBuffer, buffers = {}, jointMatrices = new Float32Array(16 * 100);
    let gltf, animationTime = 0;
    let animations = [];
    let currentAnimation = 0;

    // === FAST CHECKERBOARD GROUND SHADER ===
    let groundProgram, groundVAO, groundIndexCount;
    function createGroundShader() {
      const vs = `#version 300 es
      precision highp float;
      in vec3 position;
      uniform mat4 projection, view, model;
      out vec2 vUv;
      void main() {
        vec4 world = model * vec4(position, 1.0);
        vUv = (position.xz + 40.0) / 80.0;
        gl_Position = projection * view * world;
      }`;
      const fs = `#version 300 es
      precision highp float;
      in vec2 vUv;
      uniform sampler2D tex;
      out vec4 fragColor;
      void main() {
        fragColor = texture(tex, vUv);
      }`;
      groundProgram = createProgram(gl, vs, fs);
    }

    function createGroundQuad(size = 100) {
      const vertices = new Float32Array([
        -size, 0, -size,
         size, 0, -size,
         size, 0,  size,
        -size, 0,  size
      ]);
      const indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
      return { vertices, indices };
    }

    let groundTexture;
    function setupGround() {
        createGroundShader();
        const quad = createGroundQuad(40);
        groundVAO = gl.createVertexArray();
        gl.bindVertexArray(groundVAO);
        let vbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, quad.vertices, gl.STATIC_DRAW);
        let ebo = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, quad.indices, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
        groundIndexCount = quad.indices.length;
        gl.bindVertexArray(null);

        // Create a 2x2 color texture (e.g., green and white checkerboard)
        const texData = new Uint8Array([
            34, 139, 34, 255,   255, 255, 255, 255,
            255, 255, 255, 255, 34, 139, 34, 255
        ]);
        groundTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, groundTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, gl.UNSIGNED_BYTE, texData);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    }

    function renderGround(proj, view) {
      gl.useProgram(groundProgram);
      gl.bindVertexArray(groundVAO);
      let model = mat4.create();
     // mat4.translate(model, model, [0, -2, shipZ % 2]);
      gl.uniformMatrix4fv(gl.getUniformLocation(groundProgram, 'projection'), false, proj);
      gl.uniformMatrix4fv(gl.getUniformLocation(groundProgram, 'view'), false, view);
      gl.uniformMatrix4fv(gl.getUniformLocation(groundProgram, 'model'), false, model);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, groundTexture);
      gl.uniform1i(gl.getUniformLocation(groundProgram, 'tex'), 0);
      gl.drawElements(gl.TRIANGLES, groundIndexCount, gl.UNSIGNED_SHORT, 0);
      gl.bindVertexArray(null);
    }

    // --- Canvas resize helper ---
    function resizeCanvasToDisplaySize(canvas) {
      const dpr = window.devicePixelRatio || 1;
      const width = Math.round(canvas.clientWidth * dpr);
      const height = Math.round(canvas.clientHeight * dpr);
      if (canvas.width !== width || canvas.height !== height) {
        canvas.width = width;
        canvas.height = height;
      }
    }

    // --- Orbital camera state ---
    let orbit = {
      azimuth: 0,
      elevation: 0.5,
      radius: 8,
      dragging: false,
      lastX: 0,
      lastY: 0
    };
    canvas.addEventListener('mousedown', e => {
      orbit.dragging = true;
      orbit.lastX = e.clientX;
      orbit.lastY = e.clientY;
    });
    window.addEventListener('mousemove', e => {
      if (!orbit.dragging) return;
      const dx = e.clientX - orbit.lastX;
      const dy = e.clientY - orbit.lastY;
      orbit.azimuth += dx * 0.01;
      orbit.elevation += dy * 0.01;
      orbit.elevation = Math.max(-Math.PI/2+0.01, Math.min(Math.PI/2-0.01, orbit.elevation));
      orbit.lastX = e.clientX;
      orbit.lastY = e.clientY;
    });
    window.addEventListener('mouseup', () => { orbit.dragging = false; });
    canvas.addEventListener('wheel', e => {
      orbit.radius *= Math.exp(e.deltaY * 0.001);
      orbit.radius = Math.max(2, Math.min(orbit.radius, 50));
    });

    function createShader(gl, type, src) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, src);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(shader));
      return shader;
    }

    function createProgram(gl, vs, fs) {
      const p = gl.createProgram();
      gl.attachShader(p, createShader(gl, gl.VERTEX_SHADER, vs));
      gl.attachShader(p, createShader(gl, gl.FRAGMENT_SHADER, fs));
      gl.linkProgram(p);
      if (!gl.getProgramParameter(p, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p));
      return p;
    }

    function initShader() {
      const vs = `#version 300 es
      precision highp float;
      precision highp int;
      in vec3 position;
      in vec3 normal;
      in vec2 texcoord;
      in vec4 weights;
      in uvec4 joints;
      uniform mat4 jointMatrices[100];
      uniform mat4 projection, view, model;
      out vec3 vNormal;
      out vec2 vUv;
      out vec3 vFragPos;
      void main() {
        mat4 skin = weights.x * jointMatrices[joints.x] +
                    weights.y * jointMatrices[joints.y] +
                    weights.z * jointMatrices[joints.z] +
                    weights.w * jointMatrices[joints.w];
        mat4 mvp = projection * view * model * skin;
        gl_Position = mvp * vec4(position, 1.0);
        vNormal = mat3(transpose(inverse(model * skin))) * normal;
        vUv = texcoord;
        vFragPos = (model * skin * vec4(position, 1.0)).xyz;
      }`;
      const fs = `#version 300 es
      precision highp float;
      in vec3 vNormal;
      in vec2 vUv;
      in vec3 vFragPos;
      uniform sampler2D colorTex;
      uniform sampler2D normalTex;
      uniform sampler2D metalRoughTex;
      uniform sampler2D emissionTex;
      uniform vec3 lightPos;
      uniform vec3 lightColor;
      uniform vec3 dirLightDir; // directional light direction
      uniform vec3 dirLightColor; // directional light color
      out vec4 fragColor;
      void main() {
        vec3 baseColor = texture(colorTex, vUv).rgb;
        vec3 normalMap = texture(normalTex, vUv).rgb * 2.0 - 1.0;
        float metal = texture(metalRoughTex, vUv).b;
        float rough = texture(metalRoughTex, vUv).g;
        vec3 emission = texture(emissionTex, vUv).rgb;
        vec3 n = normalize(vNormal + normalMap * 0.5);
        // Point light
        vec3 fragPosition = vFragPos;
        vec3 lightDir = normalize(lightPos - fragPosition);
        float distance = length(lightPos - fragPosition);
        float attenuation = 1.0 / (1.0 + 0.09 * distance + 0.032 * distance * distance);
        float diffPoint = max(dot(n, lightDir), 0.0);
        vec3 pointLight = baseColor * diffPoint * (1.0 - metal) * lightColor * attenuation;
        // Directional light
        float diffDir = max(dot(n, normalize(-dirLightDir)), 0.0);
        vec3 dirLight = baseColor * diffDir * (1.0 - metal) * dirLightColor;
        vec3 color = pointLight + dirLight + emission;
        color = mix(color, vec3(0.04), metal); // simple metalness
      //  color = mix(color, vec3(1.0), 0.15); // subtle ambient
        //color = pow(color, vec3(1.0/2.2)); // gamma correction
        fragColor = vec4(color, 1.0);
      }`;
      program = createProgram(gl, vs, fs);
      gl.useProgram(program);
    }

    function initBuffers() {
      vao = gl.createVertexArray();
      gl.bindVertexArray(vao);

      function bindAttrib(data, loc, size, type, int = false) {
        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(loc);
        if (int) gl.vertexAttribIPointer(loc, size, type, 0, 0);
        else gl.vertexAttribPointer(loc, size, type, false, 0, 0);
      }

      bindAttrib(buffers.position, gl.getAttribLocation(program, 'position'), 3, gl.FLOAT);
      bindAttrib(buffers.normal, gl.getAttribLocation(program, 'normal'), 3, gl.FLOAT);
      bindAttrib(buffers.texcoord, gl.getAttribLocation(program, 'texcoord'), 2, gl.FLOAT);
      bindAttrib(buffers.weights, gl.getAttribLocation(program, 'weights'), 4, gl.FLOAT);
      bindAttrib(buffers.joints, gl.getAttribLocation(program, 'joints'), 4, gl.UNSIGNED_BYTE, true);

      indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, buffers.indices, gl.STATIC_DRAW);

      gl.bindVertexArray(null);
    }


    let lastFrameTime = performance.now();
    let frameCount = 0, fps = 0, lastFpsUpdate = performance.now();
    let animState = 'forward', animTime = 0;
    initShader();
    initBuffers(); 
    function render(time) { 
 
        const now = time || performance.now();
        const dt = Math.max(0.001, (now - lastFrameTime) * 0.001); // seconds
        lastFrameTime = now;
        animationTime += dt;
        resizeCanvasToDisplaySize(canvas);
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

   
        // --- Orbital camera calculation ---
        const target = [0, 0, 0];
        const r = orbit.radius;
        const phi = orbit.azimuth;
        const theta = orbit.elevation;
        const eye = [
          r * Math.cos(theta) * Math.sin(phi),
          r * Math.sin(theta),
          r * Math.cos(theta) * Math.cos(phi)
        ];
        const up = [0, 1, 0];
        const proj = mat4.perspective(mat4.create(), Math.PI / 4, canvas.width / canvas.height, 0.1, 100);
        const view = mat4.lookAt(mat4.create(), eye, target, up);
        // --- Render ground ---
        renderGround(proj, view);
        // --- Render environment ---
        renderEnvironment(proj, view);
 

        gl.useProgram(program);
        gl.uniformMatrix4fv(gl.getUniformLocation(program, "projection"), false, proj);
        gl.uniformMatrix4fv(gl.getUniformLocation(program, "view"), false, view);
      //  gl.uniformMatrix4fv(gl.getUniformLocation(program, "model"), false, model);

        // Bind all model textures 
      

        // --- Point light uniforms ---
        gl.uniform3fv(gl.getUniformLocation(program, 'lightPos'), [0, 2, 6]);
        gl.uniform3fv(gl.getUniformLocation(program, 'lightColor'), [0.8, 0.8, 0.8]);
        // --- Directional light uniforms ---
        gl.uniform3fv(gl.getUniformLocation(program, 'dirLightDir'), [0.5, -1.0, 0.5]); // from above front
        gl.uniform3fv(gl.getUniformLocation(program, 'dirLightColor'), [0.7, 0.7, 0.7]);

        // Update joint matrices based on animation
       // updateJointMatrices(time); 
     //   gl.uniformMatrix4fv(gl.getUniformLocation(program, "jointMatrices"), false, jointMatrices);
 
        gl.bindVertexArray(vao);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        if (buffers.indexCount) {
          gl.drawElements(gl.TRIANGLES, buffers.indexCount, gl.UNSIGNED_SHORT, 0);
        }
        gl.bindVertexArray(null);

        // --- FPS Counter ---
        frameCount++;
        if (now - lastFpsUpdate > 500) {
          fps = Math.round(frameCount * 1000 / (now - lastFpsUpdate));
          document.getElementById('fps').textContent = `FPS: ${fps}`;
          lastFpsUpdate = now;
          frameCount = 0;
        } 

        requestAnimationFrame(render); 
    
    } 

    // Call createEnvShader and setupEnvironment before rendering
    createEnvShader();
    function setupEnvironment() {
      // --- Planet ---
      let sphere = createSphere(1.2, 24, 24);
      let vao = gl.createVertexArray();
      gl.bindVertexArray(vao);
      let vbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.bufferData(gl.ARRAY_BUFFER, sphere.vertices, gl.STATIC_DRAW);
      let nbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, nbo);
      gl.bufferData(gl.ARRAY_BUFFER, sphere.normals, gl.STATIC_DRAW);
      let ebo = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, sphere.indices, gl.STATIC_DRAW);
      gl.enableVertexAttribArray(0);
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(1);
      gl.bindBuffer(gl.ARRAY_BUFFER, nbo);
      gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
      envVAOs.push(vao);
      envCounts.push(sphere.indices.length);
      envColors.push([0.2, 0.7, 1.0]); // blue planet

      // --- Stairs (5 steps) ---
      for(let i=0;i<5;++i){
        let box = createBox([2,0.3,1]);
        let vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        let vbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, box.vertices, gl.STATIC_DRAW);
        let nbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, nbo);
        gl.bufferData(gl.ARRAY_BUFFER, box.normals, gl.STATIC_DRAW);
        let ebo = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, box.indices, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(1);
        gl.bindBuffer(gl.ARRAY_BUFFER, nbo);
        gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
        envVAOs.push(vao);
        envCounts.push(box.indices.length);
        envColors.push([0.7, 0.5, 0.2]); // brown stairs
      }
      gl.bindVertexArray(null);
    }

    // === BOX GEOMETRY CREATION ===
    function createBox(size = [1,1,1]) {
      // Vertices and normals for a unit cube
      const p = [
        [-1,-1,-1],[1,-1,-1],[1,1,-1],[-1,1,-1],
        [-1,-1, 1],[1,-1, 1],[1,1, 1],[-1,1, 1]
      ];
      for (let i=0; i<8; ++i) for (let j=0;j<3;++j) p[i][j]*=size[j]/2;
      const v = [
        ...p[0],...p[1],...p[2],...p[3], // back
        ...p[4],...p[5],...p[6],...p[7], // front
        ...p[0],...p[1],...p[5],...p[4], // bottom
        ...p[2],...p[3],...p[7],...p[6], // top
        ...p[1],...p[2],...p[6],...p[5], // right
        ...p[0],...p[3],...p[7],...p[4]  // left
      ];
      const n = [
        0,0,-1, 0,0,-1, 0,0,-1, 0,0,-1,
        0,0,1, 0,0,1, 0,0,1, 0,0,1,
        0,-1,0, 0,-1,0, 0,-1,0, 0,-1,0,
        0,1,0, 0,1,0, 0,1,0, 0,1,0,
        1,0,0, 1,0,0, 1,0,0, 1,0,0,
        -1,0,0, -1,0,0, -1,0,0, -1,0,0
      ];
      const idx = [
        0,1,2, 0,2,3, 4,5,6, 4,6,7, 8,9,10, 8,10,11,
        12,13,14, 12,14,15, 16,17,18, 16,18,19, 20,21,22, 20,22,23
      ];
      return {vertices: new Float32Array(v), normals: new Float32Array(n), indices: new Uint16Array(idx)};
    }

    // === SPHERE GEOMETRY CREATION ===
    function createSphere(radius=1, latBands=16, longBands=16) {
      let vertices=[], normals=[], indices=[];
      for(let lat=0;lat<=latBands;++lat){
        let theta=lat*Math.PI/latBands;
        let sinT=Math.sin(theta), cosT=Math.cos(theta);
        for(let lon=0;lon<=longBands;++lon){
          let phi=lon*2*Math.PI/longBands;
          let sinP=Math.sin(phi), cosP=Math.cos(phi);
          let x=cosP*sinT, y=cosT, z=sinP*sinT;
          vertices.push(radius*x, radius*y, radius*z);
          normals.push(x, y, z);
        }
      }
      for(let lat=0;lat<latBands;++lat){
        for(let lon=0;lon<longBands;++lon){
          let first=lat*(longBands+1)+lon;
          let second=first+longBands+1;
          indices.push(first, second, first+1);
          indices.push(second, second+1, first+1);
        }
      }
      return {vertices:new Float32Array(vertices), normals:new Float32Array(normals), indices:new Uint16Array(indices)};
    }

    // === ENVIRONMENT RENDER ===
    function renderEnvironment(proj, view) {
      gl.useProgram(envProgram);
      for(let i=0;i<envVAOs.length;++i){
        gl.bindVertexArray(envVAOs[i]); 
        // Model matrix
        let model = mat4.create();
        if(i===0){
          // Planet position
          mat4.translate(model, model, [4,2,-2]);
        }else{
          // Stairs
          let step = i-1;
          mat4.translate(model, model, [-2+step*1.1, -1.5+step*0.35, 0]);
        }
        gl.uniformMatrix4fv(gl.getUniformLocation(envProgram, 'projection'), false, proj);
        gl.uniformMatrix4fv(gl.getUniformLocation(envProgram, 'view'), false, view);
        gl.uniformMatrix4fv(gl.getUniformLocation(envProgram, 'model'), false, model);
        gl.uniform3fv(gl.getUniformLocation(envProgram, 'color'), envColors[i]);
        gl.drawElements(gl.TRIANGLES, envCounts[i], gl.UNSIGNED_SHORT, 0);
      }
      gl.bindVertexArray(null);
    }

    // Setup ground before rendering
    setupGround();
    setupEnvironment();

   (async () => {
      try {
        //gltf = await loadGLTF("spaceship.gltf");
       // console.log('GLTF loaded successfully'); 
        // Initialize identity matrices for default pose
        for (let i = 0; i < 100; i++) {
          const matrix = mat4.create();
          mat4.identity(matrix);
          jointMatrices.set(matrix, i * 16);
        }
        initShader();
        initBuffers(); 
        gl.enable(gl.DEPTH_TEST);
        requestAnimationFrame(render);
      } catch (error) {
        console.error('Initialization error:', error);
      }
    })();
   

  </script>
</body>
</html>